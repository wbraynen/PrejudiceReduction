<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Spatialized Prisoner's Dilemma (with PTFT)</title>
  <style>
    :root{
      --panel-bg:#efefef;
      --panel-border:#c9c9c9;
      --text:#222;
    }

    body{
      margin:0;
      padding:16px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color:var(--text);
      background:#ffffff;
    }

    .app{
      max-width: 1280px;
      margin: 0 auto;
      display:grid;
      grid-template-columns: 240px 1fr 300px 240px;
      gap:16px;
      align-items:start;
    }

    .left-stack{
      grid-column: 1;
      grid-row: 1 / span 2;
      display:flex;
      flex-direction:column;
      gap:16px;
    }

    .world{
      grid-column: 2;
      grid-row: 1 / span 2;
    }

    .plots-panel{
      grid-column: 3;
      grid-row: 1;
    }

    .right-stack{
      grid-column: 4;
      grid-row: 1;
      display:flex;
      flex-direction:column;
      gap:16px;
    }

    .panel{
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 6px;
      padding: 12px;
    }

    .panel h2{
      font-size: 14px;
      margin: 0 0 10px 0;
      font-weight: 700;
    }

    .group{
      margin-top: 12px;
      padding-top: 10px;
      border-top: 1px solid #ddd;
    }

    .group-title{
      font-size: 13px;
      font-weight: 700;
      margin: 0 0 8px 0;
    }

    label{
      font-size: 12px;
      font-weight: 600;
      line-height: 1.2;
    }

    input[type="range"], select{
      width: 100%;
    }

    .slider-row{
      display:grid;
      grid-template-columns: 1fr 56px;
      align-items:center;
      gap:10px;
      margin: 10px 0;
    }

    .value-pill{
      display:inline-block;
      text-align:right;
      font-variant-numeric: tabular-nums;
      font-size: 12px;
      padding: 6px 8px;
      background: #fff;
      border: 1px solid var(--panel-border);
      border-radius: 6px;
      min-width: 56px;
      box-sizing:border-box;
    }

    .buttonbar{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top: 8px;
    }

    button{
      padding: 8px 10px;
      border: 1px solid #888;
      background: #fff;
      border-radius: 6px;
      cursor:pointer;
      font-weight: 700;
      font-size: 12px;
      text-transform: none;
      min-width: 56px;
    }

    .primary-btn{
      background: #e9f3ff;
    }

    .button-wide{
      width: 150px;
      flex: 0 0 150px;
      white-space: nowrap;
      height: 32px;
      line-height: 32px;
      padding-top: 0;
      padding-bottom: 0;
    }
    button:active{ transform: translateY(1px); }

    .world{
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    .world-title{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:12px;
    }
    .world-title h1{
      font-size: 16px;
      margin: 0;
      font-weight: 800;
    }
    .world-title .ticks{
      font-size: 12px;
      font-weight: 700;
      font-variant-numeric: tabular-nums;
    }

    .canvas-wrap{
      background:#fff;
      border: 1px solid var(--panel-border);
      border-radius: 6px;
      padding: 10px;
    }

    /* Keep logical canvas at grid size; scale visually like NetLogo patches */
    #worldCanvas{
      width: 448px;  /* 64 * 7 */
      height: 448px;
      display:block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      background:#fff;
      border: 1px solid #ddd;
    }

    .mini-table{
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
      background:#fff;
      border: 1px solid var(--panel-border);
      border-radius: 6px;
      overflow:hidden;
    }
    .mini-table th, .mini-table td{
      padding: 6px 8px;
      border-bottom: 1px solid #eee;
      text-align:left;
      font-variant-numeric: tabular-nums;
    }
    .mini-table th{
      background:#f7f7f7;
      font-weight: 800;
    }
    .mini-table tr:last-child td{ border-bottom:none; }

    .swatch{
      width: 12px;
      height: 12px;
      border: 1px solid #999;
      display:inline-block;
      vertical-align: -2px;
      margin-right: 6px;
    }

    .note{
      font-size: 12px;
      line-height: 1.35;
      color:#333;
      margin-top: 10px;
    }

    .plot-panel{
      margin-top: 12px;
    }

    .plot-canvas{
      width: 100%;
      height: 180px;
      display:block;
      background:#fff;
      border: 1px solid var(--panel-border);
      border-radius: 6px;
    }

    @media (max-width: 1050px){
      .app{ grid-template-columns: 1fr; }
      .left-stack,
      .world,
      .plots-panel,
      .right-stack{
        grid-column: auto;
        grid-row: auto;
      }
      #worldCanvas{
        width: min(90vw, 448px);
        height: min(90vw, 448px);
      }
    }
  </style>
</head>
<body>
  <div class="app">

    <!-- Left controls (NetLogo-like button column) -->
    <div class="left-stack">
      <div class="panel">
      <div class="buttonbar">
        <button id="resetBtn" class="primary-btn" title="NetLogo: setup">setup</button>
        <button id="startBtn" class="primary-btn" title="NetLogo: go">go</button>
      </div>

      <div class="buttonbar">
        <button id="toggleDisplayBtn" class="button-wide" title="NetLogo: toggle display">show "ethnicities"</button>
        <button id="desegregateBtn" class="button-wide" title="NetLogo: (de)segregate">desegregate</button>
      </div>

      <div class="group">
        <div class="slider-row">
          <label for="speed">speed (ms)</label>
          <span class="value-pill" id="speedValue">100</span>
        </div>
        <input type="range" id="speed" min="50" max="1000" value="100" step="50" />

        <div class="slider-row">
          <label for="rounds_to_play">rounds to play</label>
          <span class="value-pill" id="rounds_to_play_value">200</span>
        </div>
        <input type="range" id="rounds_to_play" min="4" max="200" step="4" value="200" />

        <div class="slider-row">
          <label for="imitation_radius">imitation radius</label>
          <span class="value-pill" id="imitation_radius_value">1.5</span>
        </div>
        <input type="range" id="imitation_radius" min="1" max="3" step="0.5" value="1.5" />
      </div>

      </div>

      <div class="panel">
        <h2>Payoffs</h2>
        <div class="slider-row">
          <label for="payoffs_cc">CC</label>
          <span class="value-pill" id="payoffs_cc_value">3</span>
        </div>
        <input type="range" id="payoffs_cc" min="0" max="10" step="1" value="3" />

        <div class="slider-row">
          <label for="payoffs_cd">CD</label>
          <span class="value-pill" id="payoffs_cd_value">0</span>
        </div>
        <input type="range" id="payoffs_cd" min="0" max="10" step="1" value="0" />

        <div class="slider-row">
          <label for="payoffs_dc">DC</label>
          <span class="value-pill" id="payoffs_dc_value">5</span>
        </div>
        <input type="range" id="payoffs_dc" min="0" max="10" step="1" value="5" />

        <div class="slider-row">
          <label for="payoffs_dd">DD</label>
          <span class="value-pill" id="payoffs_dd_value">1</span>
        </div>
        <input type="range" id="payoffs_dd" min="0" max="10" step="1" value="1" />
        <div class="buttonbar" style="justify-content:flex-end;">
          <button id="payoffsResetBtn" title="Reset payoffs to defaults">reset</button>
        </div>
      </div>
    </div>

    <!-- Center: world view (single canvas like NetLogo) -->
    <div class="world">
      <div class="world-title">
        <h1>Spatialized Prisoner's Dilemma (with PTFT)</h1>
        <div class="ticks">round: <span id="ticks">0</span></div>
      </div>

      <div class="canvas-wrap">
        <div id="displayMode" style="font-size:12px;font-weight:400;margin-bottom:6px;">Displaying strategies</div>
        <canvas id="worldCanvas" width="64" height="64"></canvas>
      </div>

    </div>

    <div class="panel plot-panel plots-panel">
      <h2>Plots (NetLogo)</h2>
      <div style="font-size:12px;font-weight:700;margin:6px 0 6px 0;">Behavior</div>
      <canvas id="behaviorPlot" class="plot-canvas" width="320" height="180"></canvas>
      <div style="font-size:12px;font-weight:700;margin:10px 0 6px 0;">Strategies</div>
      <canvas id="strategiesPlot" class="plot-canvas" width="320" height="180"></canvas>
    </div>

    <!-- Right controls (NetLogo-like sliders + strategy counts) -->
    <div class="right-stack">
      <div class="panel">
        <h2>Strategies</h2>
        <table class="mini-table">
          <tr><th>strategy</th><th>count</th></tr>
          <tr><td><span class="swatch" style="background:#00C000"></span>000 AllD</td><td id="count_s0">0</td></tr>
          <tr><td><span class="swatch" style="background:#00FFFF"></span>001</td><td id="count_s1">0</td></tr>
          <tr><td><span class="swatch" style="background:#FF0000"></span>010 STFT</td><td id="count_s2">0</td></tr>
          <tr><td><span class="swatch" style="background:#FF00FF"></span>011</td><td id="count_s3">0</td></tr>
          <tr><td><span class="swatch" style="background:#FFFF00"></span>100</td><td id="count_s4">0</td></tr>
          <tr><td><span class="swatch" style="background:#B3B3B3"></span>101</td><td id="count_s5">0</td></tr>
          <tr><td><span class="swatch" style="background:#4D4D4D"></span>110 TFT</td><td id="count_s6">0</td></tr>
          <tr><td><span class="swatch" style="background:#0000FF"></span>111 AllC</td><td id="count_s7">0</td></tr>
          <tr><td><span class="swatch" style="background:#FFB366"></span>PTFT</td><td id="count_s8">0</td></tr>
        </table>
      </div>

      <div class="panel">
        <h2>Behavior totals</h2>
        <table class="mini-table">
          <tr><th>moves</th><th>count</th></tr>
          <tr><td>C (cooperate)</td><td id="total_cooperated">0</td></tr>
          <tr><td>D (defect)</td><td id="total_defected">0</td></tr>
        </table>
      </div>
    </div>


  </div>

  <script>
    // Keep slider value pills in sync (pure UI)
    const bind = (id) => {
      const el = document.getElementById(id);
      const out = document.getElementById(id + "_value");
      if (!el || !out) return;
      const update = () => out.textContent = el.value;
      el.addEventListener("input", update);
      update();
    };
    ["payoffs_cc","payoffs_cd","payoffs_dc","payoffs_dd","rounds_to_play","imitation_radius"].forEach(bind);

    const speed = document.getElementById("speed");
    const speedValue = document.getElementById("speedValue");
    if (speed && speedValue) {
      const update = () => speedValue.textContent = speed.value;
      speed.addEventListener("input", update);
      update();
    }
  </script>

  <!-- Your NetLogo-matched JS should target the element IDs in this HTML -->
  <script>
// NetLogo-matching JS implementation
// - Strategy ids: 0..7 are reactive bit strategies; 8 is PTFT
// - Ethnicity: 0 = red, 1 = green
// - World: torus wrapping
// - Scoring: exact NetLogo payoff table (closed-form)
// - Interaction: each patch plays each of 8 neighbors directionally (double-counted)
// - Evolution: max-one-of (random tie-break) in-radius imitation_radius; adopt only if strictly higher

// ----- NetLogo strategy ids (as in the NetLogo plot) -----
const STRATEGY = {
  ALL_D: 0,      // 000
  SUSP_PERV: 1,  // 001
  STFT: 2,       // 010 (Suspicious TFT)
  S011: 3,       // 011
  C_THEN_ALL_D: 4, // 100
  S101: 5,       // 101
  TFT: 6,        // 110
  ALL_C: 7,      // 111
  PTFT: 8        // PTFT
};

// Reactive bits for strategies 0..7 (000..111)
const STRATEGY_BITS = {
  0: [0, 0, 0],
  1: [0, 0, 1],
  2: [0, 1, 0],
  3: [0, 1, 1],
  4: [1, 0, 0],
  5: [1, 0, 1],
  6: [1, 1, 0],
  7: [1, 1, 1]
};

// ----- NetLogo colors -----
// NetLogo strategy-to-color:
// 0 green, 1 cyan, 2 red, 3 magenta, 4 yellow, 5 dark gray, 6 light gray, 7 blue, 8 light orange
const STRATEGY_COLOR = {
  0: "#00C000", // green
  1: "#00FFFF", // cyan
  2: "#FF0000", // red
  3: "#FF00FF", // magenta
  4: "#FFFF00", // yellow
  5: "#B3B3B3", // light gray (approx NetLogo 3)
  6: "#4D4D4D", // dark gray (approx NetLogo 7)
  7: "#0000FF", // blue
  8: "#FFB366"  // light orange (approx NetLogo 27)
};

// NetLogo ethnicity-to-color: 0 red, 1 green
const ETHNICITY_COLOR = {
  0: "#FF0000",
  1: "#00C000"
};

function drawLinePlot(canvas, seriesList, yMax, xSpan) {
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  const w = canvas.width;
  const h = canvas.height;

  const padding = { left: 36, right: 10, top: 10, bottom: 22 };
  const plotW = w - padding.left - padding.right;
  const plotH = h - padding.top - padding.bottom;

  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0, 0, w, h);
  ctx.strokeStyle = "#c9c9c9";
  ctx.strokeRect(0.5, 0.5, w - 1, h - 1);

  const yMaxSafe = Math.max(1, yMax);
  const yFor = (v) => padding.top + (1 - v / yMaxSafe) * plotH;

  ctx.strokeStyle = "#b5b5b5";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(padding.left, padding.top);
  ctx.lineTo(padding.left, h - padding.bottom);
  ctx.lineTo(w - padding.right, h - padding.bottom);
  ctx.stroke();

  ctx.fillStyle = "#666";
  ctx.font = "10px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif";
  ctx.fillText(String(Math.round(yMaxSafe)), 4, padding.top + 8);
  ctx.fillText("0", 10, h - 8);

  if (!seriesList.length || seriesList[0].data.length === 0) return;

  const n = seriesList[0].data.length;
  const span = Math.max(2, xSpan || n);
  const xFor = (i) => {
    if (span <= 1) return padding.left;
    return padding.left + (i / (span - 1)) * plotW;
  };

  for (const series of seriesList) {
    ctx.strokeStyle = series.color;
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    series.data.forEach((v, i) => {
      const x = xFor(i);
      const y = yFor(v);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();
  }
}

function randInt(n) {
  return Math.floor(Math.random() * n);
}

function shufflePickOne(arr) {
  return arr[randInt(arr.length)];
}

class Cell {
  constructor(x, y, ethnicity, strategy) {
    this.x = x;
    this.y = y;
    this.ethnicity = ethnicity; // 0 or 1
    this.strategy = strategy;   // 0..8
    this.newStrategy = strategy;

    this.score = 0;
    this.cooperated = 0;
    this.defected = 0;
  }

  resetCounters() {
    this.score = 0;
    this.cooperated = 0;
    this.defected = 0;
  }
}

class Simulation {
  constructor() {
    // NetLogo world is 64x64 by default
    this.gridSize = 64;

    // UI state that matches NetLogo defaults:
    this.isShowEthnicities = false; // show strategies by default
    this.isSegregated = true;       // segregated by default

    this.running = false;
    this.generation = 0; // NetLogo ticks

    // Canvas
    this.canvas = document.getElementById("worldCanvas");
    this.ctx = this.canvas.getContext("2d", { alpha: false });

    // Plots
    this.strategiesPlotCanvas = document.getElementById("strategiesPlot");
    this.behaviorPlotCanvas = document.getElementById("behaviorPlot");

    // Data
    this.grid = [];
    this.totalCooperated = 0;
    this.totalDefected = 0;

    // Optional: chart/history (keep if you want)
    this.history = [];

    this.setupEventListeners();
    this.reset();
  }

  // ---- Parameters from sliders (match NetLogo widgets) ----
  get roundsToPlay() {
    return parseInt(document.getElementById("rounds_to_play").value, 10);
  }
  get imitationRadius() {
    return parseFloat(document.getElementById("imitation_radius").value);
  }
  get payoffs() {
    return {
      cc: parseInt(document.getElementById("payoffs_cc").value, 10),
      cd: parseInt(document.getElementById("payoffs_cd").value, 10),
      dc: parseInt(document.getElementById("payoffs_dc").value, 10),
      dd: parseInt(document.getElementById("payoffs_dd").value, 10)
    };
  }

  setupEventListeners() {
    document.getElementById("startBtn").addEventListener("click", () => this.toggleRun());
    document.getElementById("resetBtn").addEventListener("click", () => this.reset());
    document.getElementById("payoffsResetBtn").addEventListener("click", () => this.resetPayoffs());

    document.getElementById("toggleDisplayBtn").addEventListener("click", () => {
      this.isShowEthnicities = !this.isShowEthnicities;
      this.draw();
      this.updateDisplayButton();
      this.updateDisplayModeLabel();
    });

    document.getElementById("desegregateBtn").addEventListener("click", () => {
      this.isSegregated = !this.isSegregated;
      this.initEthnicities(); // like NetLogo: ask patches [ init_ethnicity ]
      this.draw();
      this.updateSegregationButton();
    });

    // If these sliders change, NetLogo doesn't auto-reset; but web sims often do.
    // We'll keep simulation state and just affect next steps.
    // If you prefer, call this.reset() on changes.
  }

  resetPayoffs() {
    const defaults = {
      payoffs_cc: 3,
      payoffs_cd: 0,
      payoffs_dc: 5,
      payoffs_dd: 1
    };

    for (const [id, value] of Object.entries(defaults)) {
      const el = document.getElementById(id);
      if (!el) continue;
      el.value = String(value);
      el.dispatchEvent(new Event("input", { bubbles: true }));
    }
  }

  reset() {
    this.running = false;
    this.generation = 0;
    this.history = [];

    // Canvas sizing: draw scaled pixels, but logical grid = gridSize
    // We'll make canvas a fixed display size via CSS; logical size stays gridSize.
    this.canvas.width = this.gridSize;
    this.canvas.height = this.gridSize;

    this.grid = [];
    for (let x = 0; x < this.gridSize; x++) {
      this.grid[x] = [];
      for (let y = 0; y < this.gridSize; y++) {
        // strategy = random 9 (0..8)
        const s = randInt(9);

        // ethnicity from init-patch: segregated by default, pxcor < 0 => ethnicity 0
        // With x in [0..gridSize-1], "pxcor < 0" corresponds to left half.
        const ethnicity = (x < this.gridSize / 2) ? 0 : 1;

        this.grid[x][y] = new Cell(x, y, ethnicity, s);
      }
    }

    this.totalCooperated = 0;
    this.totalDefected = 0;

    this.draw();
    this.updateStatsUI();
    this.renderPlots();
    this.updateRunButton();
    this.updateDisplayButton();
    this.updateDisplayModeLabel();
    this.updateSegregationButton();
  }

  initEthnicities() {
    // NetLogo init_ethnicity:
    // if segregated: left half ethnicity 0, right half 1
    // else random 2
    for (let x = 0; x < this.gridSize; x++) {
      for (let y = 0; y < this.gridSize; y++) {
        const c = this.grid[x][y];
        if (this.isSegregated) {
          c.ethnicity = (x < this.gridSize / 2) ? 0 : 1;
        } else {
          c.ethnicity = randInt(2);
        }
      }
    }
  }

  wrap(v) {
    const n = this.gridSize;
    return (v % n + n) % n;
  }

  cellAt(x, y) {
    return this.grid[this.wrap(x)][this.wrap(y)];
  }

  // NetLogo neighborhood: 8 neighbors for play_with_neighbors (fixed)
  getEightNeighborOffsets() {
    return [
      [ 0,  1],
      [ 1,  1],
      [ 1,  0],
      [ 1, -1],
      [ 0, -1],
      [-1, -1],
      [-1,  0],
      [-1,  1]
    ];
  }

  // NetLogo in-radius (Euclidean) for evolve; torus wrapping
  getCellsInRadius(cx, cy, r) {
    const res = [];
    const R = Math.ceil(r);
    for (let dx = -R; dx <= R; dx++) {
      for (let dy = -R; dy <= R; dy++) {
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist <= r) {
          res.push(this.cellAt(cx + dx, cy + dy)); // includes self (dx=0,dy=0)
        }
      }
    }
    return res;
  }

  // ----- PTFT resolution exactly like NetLogo my-strategy / neighbor-strategy -----
  resolveMyStrategyAgainst(me, other) {
    if (me.strategy !== STRATEGY.PTFT) return me.strategy;
    return (me.ethnicity === other.ethnicity) ? STRATEGY.TFT : STRATEGY.ALL_D;
  }

  resolveNeighborStrategyAgainst(other, me) {
    // "neighbor-strategy": what is the neighbor's strategy when they play me?
    if (other.strategy !== STRATEGY.PTFT) return other.strategy;
    return (other.ethnicity === me.ethnicity) ? STRATEGY.TFT : STRATEGY.ALL_D;
  }

  // ----- NetLogo increment_cooperated -----
  incrementCooperated(cell, inc) {
    const rounds = this.roundsToPlay;
    cell.cooperated += inc;
    cell.defected += (rounds - inc);
  }

  // ----- Exact translation of NetLogo payoff reporter -----
  payoff(s1, s2, cell) {
    const rounds = this.roundsToPlay;
    const { cc, cd, dc, dd } = this.payoffs;

    // Helper constants used in multiple cases
    const quarterMix = (cc + cd + dc + dd);

    // 000
    if (s1 === 0) this.incrementCooperated(cell, 0);
    if (s1 === 0 && s2 === 0) return rounds * dd;
    if (s1 === 0 && s2 === 1) return dd + (rounds - 1) * dc;
    if (s1 === 0 && s2 === 2) return rounds * dd;
    if (s1 === 0 && s2 === 3) return dd + (rounds - 1) * dc;
    if (s1 === 0 && s2 === 4) return dc + (rounds - 1) * dd;
    if (s1 === 0 && s2 === 5) return rounds * dc;
    if (s1 === 0 && s2 === 6) return dc + (rounds - 1) * dd;
    if (s1 === 0 && s2 === 7) return rounds * dc;

    // 001
    if (s1 === 1 && s2 === 0) { this.incrementCooperated(cell, rounds - 2); return dd + (rounds - 1) * cd; }
    if (s1 === 1 && s2 === 1) { this.incrementCooperated(cell, rounds / 2); return (rounds / 2) * dd + (rounds / 2) * cc; }
    if (s1 === 1 && s2 === 2) { this.incrementCooperated(cell, rounds / 2); return (rounds / 4) * quarterMix; }
    if (s1 === 1 && s2 === 3) { this.incrementCooperated(cell, 1); return dd + cc + (rounds - 2) * dc; }
    if (s1 === 1 && s2 === 4) { this.incrementCooperated(cell, rounds - 2); return dc + dd + (rounds - 2) * cd; }
    if (s1 === 1 && s2 === 5) { this.incrementCooperated(cell, 0); return rounds * dc; }
    if (s1 === 1 && s2 === 6) { this.incrementCooperated(cell, rounds / 2); return (rounds / 4) * quarterMix; }
    if (s1 === 1 && s2 === 7) { this.incrementCooperated(cell, 0); return rounds * dc; }

    // 010
    if (s1 === 2 && s2 === 0) { this.incrementCooperated(cell, 0); return rounds * dd; }
    if (s1 === 2 && s2 === 1) { this.incrementCooperated(cell, rounds / 2); return (rounds / 4) * quarterMix; }
    if (s1 === 2 && s2 === 2) { this.incrementCooperated(cell, 0); return rounds * dd; }
    if (s1 === 2 && s2 === 3) { this.incrementCooperated(cell, rounds - 2); return dd + dc + (rounds - 2) * cc; }
    if (s1 === 2 && s2 === 4) { this.incrementCooperated(cell, 1); return dc + cd + (rounds - 2) * dd; }
    if (s1 === 2 && s2 === 5) { this.incrementCooperated(cell, rounds / 2); return (rounds / 4) * quarterMix; }
    if (s1 === 2 && s2 === 6) { this.incrementCooperated(cell, rounds / 2); return (rounds / 2) * dc + (rounds / 2) * cd; }
    if (s1 === 2 && s2 === 7) { this.incrementCooperated(cell, rounds - 2); return dc + (rounds - 1) * cc; }

    // 011
    if (s1 === 3) this.incrementCooperated(cell, rounds - 1);
    if (s1 === 3 && s2 === 0) return dd + (rounds - 1) * cd;
    if (s1 === 3 && s2 === 1) return dd + cc + (rounds - 2) * cd;
    if (s1 === 3 && s2 === 2) return dd + cd + (rounds - 2) * cc;
    if (s1 === 3 && s2 === 3) return dd + (rounds - 1) * cc;
    if (s1 === 3 && s2 === 4) return dc + (rounds - 1) * cd;
    if (s1 === 3 && s2 === 5) return dc + cc + (rounds - 2) * cd;
    if (s1 === 3 && s2 === 6) return dc + cd + (rounds - 2) * cc;
    if (s1 === 3 && s2 === 7) return dc + (rounds - 1) * cc;

    // 100
    if (s1 === 4) this.incrementCooperated(cell, 1);
    if (s1 === 4 && s2 === 0) return cd + (rounds - 1) * dd;
    if (s1 === 4 && s2 === 1) return cd + dd + (rounds - 2) * dc;
    if (s1 === 4 && s2 === 2) return cd + dc + (rounds - 2) * dd;
    if (s1 === 4 && s2 === 3) return cd + (rounds - 1) * dc;
    if (s1 === 4 && s2 === 4) return cc + (rounds - 1) * dd;
    if (s1 === 4 && s2 === 5) return cc + dd + (rounds - 2) * dc;
    if (s1 === 4 && s2 === 6) return cc + dc + (rounds - 2) * dd;
    if (s1 === 4 && s2 === 7) return cc + (rounds - 1) * dc;

    // 101
    if (s1 === 5 && s2 === 0) { this.incrementCooperated(cell, rounds); return rounds * cd; }
    if (s1 === 5 && s2 === 1) { this.incrementCooperated(cell, rounds); return rounds * cd; }
    if (s1 === 5 && s2 === 2) { this.incrementCooperated(cell, rounds / 2); return 50 * quarterMix; } // NetLogo hardcodes 50 because rounds=200 default; keep literal translation
    if (s1 === 5 && s2 === 3) { this.incrementCooperated(cell, 2); return cd + cc + (rounds - 2) * dc; }
    if (s1 === 5 && s2 === 4) { this.incrementCooperated(cell, rounds - 2); return cc + dd + (rounds - 2) * cd; }
    if (s1 === 5 && s2 === 5) { this.incrementCooperated(cell, rounds / 2); return (rounds / 2) * cc + (rounds / 2) * dd; }
    if (s1 === 5 && s2 === 6) { this.incrementCooperated(cell, rounds / 2); return 50 * quarterMix; }
    if (s1 === 5 && s2 === 7) { this.incrementCooperated(cell, 1); return cc + (rounds - 1) * dc; }

    // 110
    if (s1 === 6 && s2 === 0) { this.incrementCooperated(cell, 1); return cd + (rounds - 1) * dd; }
    if (s1 === 6 && s2 === 1) { this.incrementCooperated(cell, rounds / 2); return 50 * quarterMix; }
    if (s1 === 6 && s2 === 2) { this.incrementCooperated(cell, rounds / 2); return (rounds / 2) * cd + (rounds / 2) * dc; }
    if (s1 === 6 && s2 === 3) { this.incrementCooperated(cell, rounds - 1); return cd + dc + (rounds - 2) * cc; }
    if (s1 === 6 && s2 === 4) { this.incrementCooperated(cell, 2); return cc + cd + (rounds - 2) * dd; }
    if (s1 === 6 && s2 === 5) { this.incrementCooperated(cell, rounds / 2); return 50 * quarterMix; }
    if (s1 === 6 && s2 === 6) { this.incrementCooperated(cell, rounds); return rounds * cc; }
    if (s1 === 6 && s2 === 7) { this.incrementCooperated(cell, rounds); return rounds * cc; }

    // 111
    if (s1 === 7) this.incrementCooperated(cell, rounds);
    if (s1 === 7 && s2 === 0) return rounds * cd;
    if (s1 === 7 && s2 === 1) return rounds * cd;
    if (s1 === 7 && s2 === 2) return cd + (rounds - 1) * cc;
    if (s1 === 7 && s2 === 3) return cd + (rounds - 1) * cc;
    if (s1 === 7 && s2 === 4) return cc + (rounds - 1) * cd;
    if (s1 === 7 && s2 === 5) return cc + (rounds - 1) * cd;
    if (s1 === 7 && s2 === 6) return rounds * cc;
    if (s1 === 7 && s2 === 7) return rounds * cc;

    // Should never happen because PTFT is resolved before payoff
    return 0;
  }

  // One directional interaction: "me plays neighbor"
  playWithNeighbor(me, neighbor) {
    const s1 = this.resolveMyStrategyAgainst(me, neighbor);
    const s2 = this.resolveNeighborStrategyAgainst(neighbor, me);
    return this.payoff(s1, s2, me);
  }

  step() {
    // NetLogo: ask patches [ play_with_neighbors ]
    // Each patch resets its counters and sums payoff vs 8 neighbors
    for (let x = 0; x < this.gridSize; x++) {
      for (let y = 0; y < this.gridSize; y++) {
        this.grid[x][y].resetCounters();
      }
    }

    const offsets = this.getEightNeighborOffsets();
    for (let x = 0; x < this.gridSize; x++) {
      for (let y = 0; y < this.gridSize; y++) {
        const me = this.grid[x][y];
        let sum = 0;
        for (const [dx, dy] of offsets) {
          const nb = this.cellAt(x + dx, y + dy);
          sum += this.playWithNeighbor(me, nb);
        }
        me.score = sum;
      }
    }

    // NetLogo: ask patches [ evolve ]
    // fittest-neighbor = max-one-of (patches in-radius imitation_radius) [score]
    // if score < [score] of fittest-neighbor -> copy its strategy else keep own
    const r = this.imitationRadius;
    for (let x = 0; x < this.gridSize; x++) {
      for (let y = 0; y < this.gridSize; y++) {
        const me = this.grid[x][y];
        const neighborhood = this.getCellsInRadius(x, y, r);

        let maxScore = -Infinity;
        for (const c of neighborhood) maxScore = Math.max(maxScore, c.score);

        // random tie-break like NetLogo max-one-of
        const best = shufflePickOne(neighborhood.filter(c => c.score === maxScore));

        me.newStrategy = (me.score < best.score) ? best.strategy : me.strategy;
      }
    }

    // NetLogo: ask patches [ set strategy new_strategy ]
    for (let x = 0; x < this.gridSize; x++) {
      for (let y = 0; y < this.gridSize; y++) {
        this.grid[x][y].strategy = this.grid[x][y].newStrategy;
      }
    }

    // NetLogo: init-global-counters + ask patches [ count-total-cooperated ]
    this.totalCooperated = 0;
    this.totalDefected = 0;
    for (let x = 0; x < this.gridSize; x++) {
      for (let y = 0; y < this.gridSize; y++) {
        const c = this.grid[x][y];
        this.totalCooperated += c.cooperated;
        this.totalDefected += c.defected;
      }
    }

    this.generation++;
    this.draw();
    this.updateStatsUI();
    this.updateHistory(); // optional chart
    this.renderPlots();
  }

  draw() {
    // Draw either strategies or ethnicities, like NetLogo display-agents
    for (let x = 0; x < this.gridSize; x++) {
      for (let y = 0; y < this.gridSize; y++) {
        const c = this.grid[x][y];
        const fill = this.isShowEthnicities
          ? ETHNICITY_COLOR[c.ethnicity]
          : STRATEGY_COLOR[c.strategy];

        this.ctx.fillStyle = fill;
        this.ctx.fillRect(x, y, 1, 1);
      }
    }
  }

  updateStatsUI() {
    // Match NetLogoâ€™s semantics: plots show COUNTS, behavior shows totals
    const counts = new Array(9).fill(0);
    for (let x = 0; x < this.gridSize; x++) {
      for (let y = 0; y < this.gridSize; y++) {
        counts[this.grid[x][y].strategy]++;
      }
    }

    const setText = (id, v) => {
      const el = document.getElementById(id);
      if (el) el.textContent = String(v);
    };

    setText("ticks", this.generation);

    // Strategy counts (like NetLogo plot pens)
    setText("count_s0", counts[0]);
    setText("count_s1", counts[1]);
    setText("count_s2", counts[2]);
    setText("count_s3", counts[3]);
    setText("count_s4", counts[4]);
    setText("count_s5", counts[5]);
    setText("count_s6", counts[6]);
    setText("count_s7", counts[7]);
    setText("count_s8", counts[8]);

    // Behavior totals (like NetLogo Behavior plot)
    setText("total_cooperated", this.totalCooperated);
    setText("total_defected", this.totalDefected);
  }

  updateHistory() {
    // Optional: keep history in counts like NetLogo plots (not percents)
    const counts = new Array(9).fill(0);
    for (let x = 0; x < this.gridSize; x++) {
      for (let y = 0; y < this.gridSize; y++) {
        counts[this.grid[x][y].strategy]++;
      }
    }

    this.history.push({
      tick: this.generation,
      strategies: counts,
      cooperated: this.totalCooperated,
      defected: this.totalDefected
    });
  }

  renderPlots() {
    if (!this.history.length) {
      drawLinePlot(this.strategiesPlotCanvas, [], this.gridSize * this.gridSize, 30);
      drawLinePlot(this.behaviorPlotCanvas, [], 7000000, 30);
      return;
    }

    const strategySeries = [];
    for (let i = 0; i < 9; i++) {
      strategySeries.push({
        color: STRATEGY_COLOR[i],
        data: this.history.map(h => h.strategies[i])
      });
    }
    const maxStrategies = this.gridSize * this.gridSize;
    const span = Math.max(30, this.history.length);
    drawLinePlot(this.strategiesPlotCanvas, strategySeries, maxStrategies, span);

    const behaviorSeries = [
      { color: "#2e7d32", data: this.history.map(h => h.cooperated) },
      { color: "#c62828", data: this.history.map(h => h.defected) }
    ];
    let maxBehavior = 7000000;
    for (const h of this.history) {
      if (h.cooperated > maxBehavior) maxBehavior = h.cooperated;
      if (h.defected > maxBehavior) maxBehavior = h.defected;
    }
    drawLinePlot(this.behaviorPlotCanvas, behaviorSeries, Math.ceil(maxBehavior * 1.05), span);
  }

  start() {
    this.running = true;
    this.runLoop();
  }

  pause() {
    this.running = false;
  }

  toggleRun() {
    if (this.running) this.pause();
    else this.start();
    this.updateRunButton();
  }

  updateRunButton() {
    const btn = document.getElementById("startBtn");
    if (!btn) return;
    btn.textContent = this.running ? "pause" : "go";
    btn.title = this.running ? "Pause" : "NetLogo: go";
  }

  updateDisplayButton() {
    const btn = document.getElementById("toggleDisplayBtn");
    if (!btn) return;
    btn.textContent = this.isShowEthnicities ? "show strategies" : "show \"ethnicities\"";
  }

  updateDisplayModeLabel() {
    const label = document.getElementById("displayMode");
    if (!label) return;
    label.textContent = this.isShowEthnicities
      ? "Displaying \"ethnicities\""
      : "Displaying strategies";
  }

  updateSegregationButton() {
    const btn = document.getElementById("desegregateBtn");
    if (!btn) return;
    btn.textContent = this.isSegregated ? "desegregate" : "segregate";
  }

  runLoop() {
    if (!this.running) return;
    this.step();

    const speedEl = document.getElementById("speed");
    const delay = speedEl ? parseInt(speedEl.value, 10) : 50;
    setTimeout(() => this.runLoop(), delay);
  }
}

// Initialize
const sim = new Simulation();

</script>
</body>
</html>
